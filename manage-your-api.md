# 前端工程师的向上管理

## 背景

前端的上游是后端，后端的上游是数据，数据的上游是算法。

数据、算法太远，前端能管的就只有后端了，准确的说，不是管人，是管后端接口。

目前看来 restful 接口还将继续发光发热很久，完全没有被替代的迹象。

所以本篇说的，都是 restful 接口的一些最佳实践。

## 接口功能分类

### 列表

#### URL

例如：`GET /api/records` 用复数形式路径代表列表，或`GET /api/record/list` 使用 list 表示列表含义。

#### 入参

通常为一系列键值对构成的搜索条件与分页参数。

#### 返回

为一个对象，列表数组，一些分页参数等，返回的 header 中务必包含`Content-Type: application/json;charset=UTF-8`。

#### 例外

如果搜索条件中有些数据可能很大，例如SKU，则应改为 POST 方法。否则会有超出浏览器 url 长度限制的问题。[参考](https://stackoverflow.com/questions/15090220/maximum-length-for-url-in-chrome-browser)

__所以如果考虑编程风格一致性的话，统一都使用 POST 请求也挺好。__

### 单个数据详情

#### URL

两种设计风格，例如：

`GET /api/record/111`或者`GET /api/record?id=111`

按 restful 规范来说，左边的符合规范，业界大部分的开放 api 也是这种风格。

但右边的在工程设计上也并没有什么违和感，不过在同一个工程中，请务必统一风格。

需要注意，如果使用路径参数，则路径参数为必填的。

__经过长期编码的自我感知，我认为如果有且仅有一个参数，可以考虑路径参数的风格，否则最好都用query的方法。__

#### 入参

一般来说，入参只有一个 id，也可能按业务含义叫 orderId、 planId 等。

#### 返回

返回该 id 对应的数据对象 json

💡此处也有注意点，例如下面`/api/book/111`，此处的id，可能是bookId、orderId，也可能是userId，如果接口不是你自己定义的，最好不要随便瞎猜定义中id的含义，不如用对象来定义参数，键值含义明确对应。

因为我碰上过这种`/api/promo/:sku`，用sku取促销的接口，每次都得确认一下，传的路径参数到底是不是`promo_id`

### 创建数据

#### URL

例如`POST /api/record/create`

按 restful 规范，肯定应该使用 POST 方法请求，但请求体按以下两种情况，分为两种数据结构。

#### 入参

无上传文件的情况请求体为 JSON，该接口的 swagger 定义中，请求 header必须有`Accept: application/json`，表明可接受的数据类型。

上传文件的情况非JSON格式请求请求体为传统的 html 表单提交格式，swagger 中看到的入参格式大概是`application/x-www-form-urlencoded`

该结构，仅支持一维键值对，例如：

```text
name: xxx
startTime: 2020-10-10
file: .....(Binary content)
rule: [{"name": "xxx", "enabled": true}]
```

该模式的问题就在于仅支持一维的数据，如果里面有多层的数据结构，则第二层之后的数据只能使用手动JSON序列化的字符串，如上面的`rule`字段，往往需要添加很多数据转换逻辑，且破坏了工程中的数据结构校验流程，后端接收该数据后也需要手动解析数据结构，加大了数据校验难度，不是很推荐。

JSON格式请求虽然 JSON 中没法包含二进制文件，但可以通过 base64 序列化成字符串，缺点是会导致请求体更大了一些，适合上传数据较小，不在乎数据流量的情况（非移动端网络），例如。

```json
{
  "name": "xxx",
  "startTime": "2020-10-10",
  "file": "base64 encoded content........",
  "rule": [{"name": "xxx", "enabled": true}]
}
```

该情况下，对于文件的 base64 处理前后端都需要手动额外编码，好处是可以保住所有数据类型的数据结构，数据校验也方便。

#### 返回

返回的情况按需设计，可能只是一个提示，返回 string 即可，header 中务必包含`Content-Type: plain/text;charset=UTF-8`。

😓 这种情况下，只能显示文本而已，丧失了通过编程对特殊逻辑处理的掌控力。

🚥 一开始我觉得也还能接受这种文本的提示，但后来我改变了想法，否定了这种设计。这样只能处理正向逻辑，无法处理反向逻辑或错误！

因此还是推荐返回一个JSON对象，这样可以包含一些业务需求逻辑，至少可以处理正向、反向逻辑了，header 中务必包含`Content-Type: application/json;charset=UTF-8`。

### 更新数据

#### URL

`PUT /api/record/id` 数据 id 放在路径中， 或 PUT/api/record ，数据 id 放在请求体 JSON 中。

#### 入参

除了多了一个必须的 id 参数来锚定对应的数据外，其他与创建数据一样，也需要区分是否有上传文件的情况。

#### 💣数据转换🙏

有时提交的数据需要根据业务逻辑转换，例如：提交的是百分比数据，表单内填的是 10% ，提交的时数据保存的是 0.1

👾那么问题来了，这种转换是应该前端转还是后端转？是否应该表单中显示的数据与提交到接口的数据保持一致？

#### 返回

同创建数据

### 删除数据

有单个删除与批量删除两种情况，但实际上，前端只需要批量删除接口，即使页面上有单独删除的操作，也复用调用批量删除的接口。

因此删除单独数据的接口基本没必要写。

#### URL

`DELETE /api/records`

按 restful 的标准来说 DELETE 方法是 不能 传 body 的，所以咱还是改成`POST /api/records/remove`

入参一般为 JSON，是被删除数据的 id 数组，例如：

```json
[1, 2, 3]
```

#### 返回

由于是批量操作，返回的数据可能类似以下几种例子，或其他自行设计的数据结构

```json
["数据1删除成功", "数据2删除成功", "数据3删除失败，原因：xxx"]
```

或

```json
[[1, true, "成功"], [2, true, "成功"], [3, false, "失败原因：xxx"]]
```

注意，第一种字符串形式，只能起到简单的文字显示提示作用，也就是无论成功失败，提示形式都无法区分。

💡要想精准显示，还是推荐类似第二种这种方式，每条信息中可以明确判断该提示是成功或失败，当然格式__不限于__该例子。

### 其他操作类请求

按业务需求设计，例如批量开始`PUT /api/records/start` ，批量停止`PUT /api/records/stop`等。

如果是例如上面的那两种操作，仅仅是改变了数据的状态，则入参与返回，都与删除操作一样设计即可。

如果操作不仅仅是数据单一状态的更新，还涉及到一些其他属性的批量更新，则入参设计会稍微复杂一些，不能仅仅为一个 id 的数组，例如：

```json
[{"id": "1", startDate: "2022-02-02"}, {"id": "2", startDate: "2022-02-02"}]
```

但如果是上面这种操作，无论批量或不批量操作，可能会有一系列近似的行为，比如开始、结束、启用、停用，入参与返回几乎一模一样，此时定义多个接口感觉有些重复。

可以设计成这种`PUT /api/records/action`

入参例如：

```json
{
  "ids": [1, 2, 3],
  "action": "start"  // 枚举 例如 enable | disable | start | stop
}
```

#### 例外

但现实世界，就没有简单的事，如果后端系统，是以 api 路径为单元来划分权限，且 开始、结束、启用、停用 这些操作都需要单独的权限控制，则还是必须得用一开始那种模式，将所有请求接口单独定义。

__凡事都要根据实际需求灵活调整。__

#### 批量数据操作校验

如果批量数据操作，收到数据的状态限制，这种限制应该放前端还是后端呢。

比如刚创建的订单可以删除，一旦进入流程就不能再删除了。一种方法是提供订单的状态给前端，前端根据状态判断是否可删除，并做出操作上的优化。

另一种方法是将是否可删除封装到接口中的一个属性上，比如：canDelete: boolean，前端不管具体的业务逻辑，只根据该属性判断并进行操作上的优化。

哪种方法更好？

### 一些通用设计原则

* 凡是返回JSON的接口，返回 header中必须有`Content-Type: application/json;charset=UTF-8`
* 凡是接收JSON的接口，swagger定义的入参要有可接收类型：`application/json`
* 所有会导致系统内部数据变化的，创建、更新、导出、删除等，不要使用 GET 请求。
* 凡是使用了__非__ GET 请求方法的接口，参数__不__要再放到 query 里了。
* __不__ 要混放参数，比如一个接口里，有query还有body，搞不清就都用post方法，放body里。
* 批量操作的返回类型，除非需求只是简单的提示一下“成功”或“失败”，最好别用字符串，因为批量操作数据量可能很大，返回较长的字符串，一是不方便展示，二是无法区分其中的可能出现的各种情况和细分逻辑，最好还是返回对象。
* 由于 GET 请求的限制，比如 URL 长度限制，参数只能一维等，绝大多数接口都用 POST 也挺好。

    例外：无参数的 api 还是用 GET，比如获取当前登录人信息 GET /api/userinfo，符合直觉和语义 。

* 如果是需要前端计算的数据，需要返回原始的数字类型，不要返回格式化的字符串，例如需要画图的数据，不要返回 "34%"，需要返回原始数字类型 0.34。

### 后续补充

导入导出模版，下载模版的接口，应由后端提供，与上传解析时的字段保持统一。

### 接口命名

一般来说，接口都会以 /api 开头，后面接业务领域名称，比如  /api/order，再后面接执行的动作比如  /api/order/[create,update,list]

最多的问题是命名冗余，举个例子： /api/order/saveOrder

如果一个接口的属性的是一组erp或sku，是用一个逗号分隔的字符串（'aaa,bbb,ccc'），还是改名为erpList或skuList，用字符串数组（['aaa', 'bbb', 'ccc']）表示好呢？

### 靠 http status 还是返回的 json 里的 code 来反馈报错？

http status 用来反馈进程服务异常，是不可控错误，一般不会返回什么有用的提示信息。

根据返回 json 中的 code 用来反馈业务错误，是可控的由业务逻辑反馈的异常，需要附带错误解释信息。

这两条规则不要混用。

### 出入参数中的大JSON字段

（不要在出入参中使用大JSON字段！） * 3

例如返回数据中的 json 信息，使用 JSON.parse 不仅需要运行时 try catch，即使成功解析出来的数据，也仅仅是口头约定的符合某种数据类型，实际生产中会出各种各样的问题。

属性丢失，层级不对应等等。

除非是非固定类型的仅是展示用的，例如各种各样的 log 信息。

否则的话会丧失了编译时的类型校验，把报错推到了运行时，直接在客户使用时报错！

### 精简出入参，做减法

最大的问题就是冗余，经常会有好多无用的属性，虽然不影响使用，但是会对后续维护产生很多隐形问题。

比如返回对象属性中有  oppUrl 与 opp.oppUrl ，在开发时口头约定指定使用了一个，但后续迭代持续使用该接口过程中，很可能会将这种命名非常类似的属性搞错。

总之对入参与出参的暴露的数据结构，应务必争取做到，有且仅有，专项专用。

做减法！

最后引用一句名言结束（延伸到各个编程领域的命名行为）

__注意你的思想，它会变成你的言语；注意你的言语，它会变成你的行动；注意你的行动，它会变成你的习惯；注意你的习惯，它会变成你的性格；注意你的性格，它会变成你的命运。__
